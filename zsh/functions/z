# vim: filetype=zsh foldmethod=marker
# knowledge management using unix tools.

# Init {{{
local GREPPRG=rg
local FINDPRG=fd
local AUTHOR="Arumoy Shome"
local CATPRG=glow
[[ -z $NOTESFORMAT ]] && local NOTESFORMAT="md"
[[ -z $NOTESDIR ]] && local NOTESDIR="$HOME/org"
[[ -z $TEMPLATEDIR ]] && local TEMPLATEDIR="$NOTESDIR/.templates"
[[ ! -d $NOTESDIR ]]  && mkdir -p $NOTESDIR
# }}}

# Agenda {{{
__agenda () {
  emulate -L zsh

  # 1: type
  # 2: project
  # 3: file name
  # 4: title
  local PRETTYRX="(\w+)@(\w+)--(.+)\.$NOTESFORMAT:#+\s(.+)$"
  local PRETTYPRINT=' $1|$2|$3|$4 '
  local QUERYRX='^#+\s.+'
  local TMP='/tmp/z-find-results.txt'

  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --type | -t)
        shift
        local TYPE="${1:l}" # lowercase
        if [[ -z "$TYPE" ]]; then
          echo "Error: type cannot be empty."
          return 1
        fi
        ;;
      --project | -p)
        shift
        local PROJECT="${1:l}" # lowercase
        if [[ -z "$PROJECT" ]]; then
          echo "Error: project cannot be empty."
          return 1
        fi
        ;;
      *)
        ;;
    esac; shift
  done

  local FINDCMD='__find' # open braces
  [[ "$TYPE" ]] && FINDCMD="$FINDCMD --type $TYPE"
  [[ "$PROJECT" ]] && FINDCMD="$FINDCMD --project $PROJECT"
  eval $FINDCMD > $TMP

  if [[ -s "$TMP" ]]; then
    $GREPPRG --no-heading --no-line-number --with-filename --smart-case --max-depth 1 \
      $QUERYRX $(cat $TMP) | \
      $GREPPRG $PRETTYRX -r $PRETTYPRINT | \
      column -t -s '|'
  fi
}
# }}}

# Grep {{{
__grep () {
  emulate -L zsh

  local CMD="$GREPPRG --smart-case --max-depth 1 --type $NOTESFORMAT"
  local FINDCMD='__find'

  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h )
        echo "grep: grep wrapper for notes files."
        echo "--type -t: limit to files matching specified type."
        echo "--project -p: limit to files matching specified project."
        echo "All additional arguments are passed to $GREPPRG verbatim."
        return 0
        ;;
      --type | -t)
        shift
        local TYPEFLAG=1
        FINDCMD="$FINDCMD --type ${1:l}" # lowercase
        ;;
      --project | -p)
        shift
        local PROJECTFLAG=1
        FINDCMD="$FINDCMD --project ${1:l}" #lowercase
        ;;
      *)
        # NOTE: similar to what we do in find, assume that the rest of
        # the args are to be passed along to GREPPRG.
        break
        ;;
    esac; shift
  done

  if [[ "$TYPEFLAG" || "$PROJECTFLAG" ]]; then
    CMD="$FINDCMD --exec-batch $CMD"
  fi

  # pass any additional args
  [[ "$@" ]] && CMD="$CMD $@"

  eval $CMD
}
# end Grep }}}

# Find {{{
__find() {
  emulate -L zsh

  # Show Tags {{{
  __show_tags () {
    $FINDPRG --max-depth 1 --extension $NOTESFORMAT | \
      $GREPPRG $1 -r '$1' | \
      sort | \
      uniq -c | \
      sort --reverse | \
      column
  }
  # end Show Tags }}}

  local SHOWTYPESRX='^(\w+)@\w+--.+'
  local SHOWPROJECTSRX='^\w+@(\w+)--.+'
  local CMD="$FINDPRG --max-depth 1 --extension $NOTESFORMAT"
  local TYPE='\w+'
  local PROJECT='(\w+)?'

  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h )
        echo "find: find files matching a specific type or project."
        echo "--type -t: find files matching the specified type."
        echo "--project -p: find files matching the specified project."
        echo "--edit -e: edit matching files with $EDITOR."
        echo "--show-types: print types."
        echo "--show-projects: print projects."
        echo "All additional arguments are passed to $FINDPRG verbatim."
        return 0
        ;;
      --type | -t)
        shift
        local TYPEFLAG=1
        local TYPE="${1:l}" # lowercase
        ;;
      --project | -p)
        shift
        local PROJECTFLAG=1
        local PROJECT="${1:l}" # lowercase
        ;;
      --edit | -e)
        local EDITFLAG=1
        ;;
      --show-types)
        __show_tags $SHOWTYPESRX
        return 0
        ;;
      --show-projects)
        __show_tags $SHOWPROJECTSRX
        return 0
        ;;
      *)
        # NOTE: assume that we are done with our args and the rest are
        # to be passed to FINDPRG verbatim.
        break
    esac; shift
  done

  if [[ "$TYPEFLAG" || "$PROJECTFLAG" ]]; then
    local QUERYRX="^${TYPE}@${PROJECT}--[\w-]+"
    CMD="$CMD '$QUERYRX'"
  fi

  # pass any additional args
  [[ "$@" ]] && CMD="$CMD $@"

  # handle --edit flag
  [[ "$EDITFLAG" ]] && CMD="$CMD --exec-batch $EDITOR"

  eval $CMD
}
# end Find }}}

# New {{{
__new() {
  emulate -L zsh

  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h)
        echo "new: create a new note file."
        echo "--no-edit -x: just create the file, don't open it."
        echo "--type -t: specify the type."
        echo "--project -p: specify a project."
        echo "--name -n: specify the title."
        return 0
        ;;
      --type | -t)
        shift
        local TYPE="${1:l}" # lowercase
        if [[ -z "$TYPE" ]]; then
          echo "Error: type cannot be empty."
          return 1
        fi
        ;;
      --project | -p)
        shift
        local PROJECT="${1:l}" # lowercase
        if [[ -z "$PROJECT" ]]; then
          echo "Error: project cannot be empty."
          return 1
        fi
        ;;
      --name | -n )
        shift
        local NAME="$1"
        NAME=${NAME:l} # lowercase words
        NAME=${NAME// /-} # substitute spaces with hyphens
        if [[ -z "$NAME" ]]; then
          echo "Error: name cannot be empty."
          return 1
        fi
        ;;
      --no-edit | -x )
        local NOEDITFLAG=1
        ;;
      *)
        echo "Error: unknown option $1."
        return 1
        ;;
    esac; shift
  done

  # NOTE: we build the file name outside the while loop above because
  # the arguments may be passed in random order however we want to
  # construct the name in a specific order.
  local RESULT="$TYPE"
  [[ "$PROJECT" ]] && RESULT="$RESULT@$PROJECT"
  RESULT="$RESULT--$NAME.$NOTESFORMAT"

  if [[ ! -e "$RESULT" ]]; then
    echo "Info: $RESULT does not exist, creating file."
    touch $RESULT

    local TEMPLATEFILE="$TEMPLATEDIR/$TYPE"
    if [[ -e "$TEMPLATEFILE" ]]; then
      if [[ -x "$TEMPLATEFILE" ]]; then
        $TEMPLATEFILE $RESULT
      elif [[ -s "$TEMPLATEFILE" ]]; then
        cat $TEMPLATEFILE > $RESULT
      fi
    else
      echo "---" > $RESULT
      echo "title: $NAME" >> $RESULT
      echo "date: [$(date +'%Y-%m-%d')]" >> $RESULT
      echo "author: $AUTHOR" >> $RESULT
      echo "---" >> $RESULT
    fi
  fi

  [[ ! "$NOEDITFLAG" ]] && __edit + $RESULT
}
# }}}

# Link {{{
__link() {
  emulate -L zsh

  # Backward Links {{{
  __backward_links() {
    emulate -L zsh

    echo "Info: backward links."
    $GREPPRG --max-depth 1 --files-with-matches --type $NOTESFORMAT "\($1\)" | \
      $GREPPRG --no-line-number --only-matching "^(.+)\.$NOTESFORMAT" -r '$1'
  }
  # }}}

  # Forward Links {{{
  __forward_links() {
    emulate -L zsh

    echo "Info: forward links."
    $GREPPRG '\((\d+-\d+-\d+--\w+--[\w-]+)\)' $1 --no-line-number \
      --only-matching --replace '$1'
  }
  # }}}

  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h )
        echo "link: show links for note."
        echo "--forward -f: show notes that given note links to."
        echo "--backward -b: show notes which link to given note."
        echo "--unlinked -u: show unlinked notes."
        return 0
        ;;
      --forward | -f )
        shift
        local FORWARDFLAG=1
        ;;
      --backward | -b )
        shift
        local BACKWARDFLAG=1
        ;;
      *)
        local NAME=${1:t:r} # file name without extension and absolute path
        break
        ;;
    esac
  done

  if [[ -z "$1" || ! -e "$1" ]]; then
    echo "Error: no or unexisting file specified."
    return 1
  fi

  if [[ -n "$FORWARDFLAG" ]]; then
    __forward_links $1
  elif [[ -n "$BACKWARDFLAG" ]]; then
    __backward_links $NAME
  else
    __forward_links $1
    __backward_links $NAME
  fi
}
# }}}

# Standup {{{
__standup() {
  emulate -L zsh

  local CAPTUREGLOB="capture@*.$NOTESFORMAT"
  local PERIOD='1w'

  [[ "$1" ]] && PERIOD=$1

  echo "Info: showing notes changed within $PERIOD."
  $FINDPRG --max-depth 1 --changed-within $PERIOD --extension $NOTESFORMAT \
    --exclude $CAPTUREGLOB
}
# }}}

# Edit {{{
__edit() {
  emulate -L zsh

  $EDITOR $@
}
# }}}

# Cat {{{
__cat() {
  local BG=$(tail -n 1 ~/.vim/.background)
  local WIDTH=72
  echo "Info: showing $@."
  $CATPRG -w $WIDTH -s $BG $@
}
# }}}

# Main {{{
if [[ "$PWD" != "$NOTESDIR" ]]; then
  pushd $NOTESDIR
  local PUSHDFLAG=1
fi

if [[ "$#" -eq 0 ]]; then
  __agenda
else
  case "$1" in
    help)
      echo "z: knowledge management using standard unix tools."
      echo "capture: subcommand to open the default notes file and start capture process."
      echo "grep: subcommand to print a list of headers. See z grep --help for more info."
      echo "find: subcommand to print a list of files. See z find --help for more info."
      echo "cd: subcommand to change current directory to default notes directory."
      echo "new: subcommand to create new note file. See z new --help for more info."
      echo "link: subcommand to find links between notes. See z link --help for more info."
      echo "standup: subcommand to show latest modified notes."
      return 0
      ;;
    grep | rg | g)
      __grep "${@:2}"
      ;;
    find | fd | f)
      __find "${@:2}"
      ;;
    capture | cap | c)
      __capture "${@:2}"
      ;;
    new | n)
      __new "${@:2}"
      ;;
    cd)
      return 0 # already in NOTESDIR
      ;;
    cat)
      __cat "${@:2}"
      ;;
    rm | mv)
      rm ${@:2}
      ;;
    link | l)
      __link "${@:2}"
      ;;
    standup | stand | s)
      __standup "${@:2}"
      ;;
    agenda | age | a)
      __agenda "${@:2}"
      ;;
    *)
      __edit $@
      ;;
  esac
fi

if [[ "$PUSHDFLAG" ]]; then
  popd
fi
# }}}
