# vim: filetype=zsh foldmethod=marker
# knowledge management using unix tools.

# Init {{{
local GREPPRG=rg
local FINDPRG=fd
local AUTHOR="Arumoy Shome"
local CATPRG=glow
[[ -z $NOTESFORMAT ]] && local NOTESFORMAT="md"
[[ -z $NOTESDIR ]] && local NOTESDIR="$HOME/org"
[[ -z $TEMPLATEDIR ]] && local TEMPLATEDIR="$NOTESDIR/.templates"
[[ ! -d $NOTESDIR ]]  && mkdir -p $NOTESDIR
# }}}

# Agenda {{{
__agenda () {
  emulate -L zsh

  # 1: type
  # 2: project
  # 3: file name
  # 4: title
  local PRETTYRX="(\w+)@(\w+)--(.+)\.$NOTESFORMAT:#+\s(.+)$"
  local PRETTYPRINT=' $1|$2|$3|$4 '
  local QUERYRX='^#+\s.+'

  $GREPPRG --no-heading --no-line-number --with-filename --smart-case \
    --max-depth 1 --type $NOTESFORMAT $@ $QUERYRX | \
    $GREPPRG $PRETTYRX -r $PRETTYPRINT | column -t -s '|'
}
# }}}

# Capture {{{
__capture () {
  emulate -L zsh

  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h)
        echo "capture: convenient wrapper around new."
        echo "--project -p: specify a project."
        return 0
        ;;
      --project | -p)
        shift
        PROJECT="${1:l}" #lowercase
        if [[ -z "$PROJECT" ]]; then
          echo "Error: project cannot be empty."
          return 1
        fi
        ;;
      *)
        echo "Error: unknown option $1."
        return 1
        ;;
    esac; shift
  done

  local UUID=$(uuidgen)
  UUID=${UUID:l} # lowercase
  UUID=${UUID: -12} # last 12 chars

  if [[ "$PROJECT" ]]; then
    __new --type capture --name $UUID --project $PROJECT
  else
    __new --type capture --name $UUID
  fi
}
# }}}

# Grep {{{
__grep () {
  emulate -L zsh

  case "$1" in
    --help | -h )
      echo "grep: grep wrapper for notes files."
      echo "Invoke ripgrep with provided arguments."
      return 0
      ;;
    *)
      $GREPPRG --smart-case --max-depth 1 --type $NOTESFORMAT $@
      ;;
  esac
}
# }}}

# Find {{{
__find() {
  emulate -L zsh

  local CAPTURERX='capture@(\w+)?--[\w-]+'
  local SHOWTYPESRX='^(\w+)@\w+--.+'
  local SHOWPROJECTSRX='^\w+@(\w+)--.+'

  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h )
        echo "find: find files matching a specific type or project."
        echo "--type -t: print files matching the specified type."
        echo "--project -p: print files matching the specified project."
        echo "--show-types: print types."
        echo "--show-projects: print projects."
        echo "With any other arguments, invoke fd with provided arguments."
        echo "All additional arguments are passed to fd verbatim."
        return 0
        ;;
      --type | -t)
        shift
        local TYPE="${1:l}" # lowercase
        if [[ -z "$TYPE" ]]; then
          echo "Error: type cannot be empty."
          return 1
        fi
        ;;
      --project | -p)
        shift
        local PROJECT="${1:l}" # lowercase
        if [[ -z "$PROJECT" ]]; then
          echo "Error: project cannot be empty."
          return 1
        fi
        ;;
      --edit | -e)
        local EDITFLAG=1
        ;;
      --show-types)
        $FINDPRG --max-depth 1 --extension $NOTESFORMAT | \
          $GREPPRG $SHOWTYPESRX -r '$1' | \
          sort | \
          uniq -c | \
          sort --reverse | \
          column
        return 0
        ;;
      --show-projects)
        $FINDPRG --max-depth 1 --extension $NOTESFORMAT | \
          $GREPPRG $SHOWPROJECTSRX -r '$1' | \
          sort | \
          uniq -c | \
          sort --reverse | \
          column
        return 0
        ;;
      *)
        echo "Error: unknown option $1."
        return 1
    esac; shift
  done

  # NOTE: these cannot be define at the top since they depend on the
  # values extracted from the arguments.
  local TYPERX="^${TYPE}@(\w+)?--[\w-]+"
  local PROJECTRX="^\w+@${PROJECT}--[\w-]+"
  local TYPEPROJECTRX="^${TYPE}@${PROJECT}--[\w-]+"
  local COMMAND="$FINDPRG --max-depth 1 --extension $NOTESFORMAT"

  # pass the appropriate regex.
  # NOTE that we have to quote the regex expression in single quotes
  # since we are using eval later.
  if [[ "$TYPE" && "$PROJECT" ]]; then
    COMMAND="$COMMAND '$TYPEPROJECTRX'"
  elif [[ "$TYPE" ]]; then
    COMMAND="$COMMAND '$TYPERX'"
  elif [[ "$PROJECT" ]]; then
    COMMAND="$COMMAND '$PROJECTRX'"
  else
    COMMAND="$COMMAND '$CAPTURERX'"
  fi

  # pass any additional args
  COMMAND="$COMMAND ${@:3}"

  # handle --edit flag
  if [[ "$EDITFLAG" ]]; then
    COMMAND="$COMMAND --exec-batch $EDITOR"
  fi

  eval $COMMAND
}
# }}}

# New {{{
__new() {
  emulate -L zsh

  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h)
        echo "new: create a new note file."
        echo "--no-edit -x: just create the file, don't open it."
        echo "--type -t: specify the type."
        echo "--project -p: specify a project."
        echo "--name -n: specify the title."
        return 0
        ;;
      --type | -t)
        shift
        local TYPE="${1:l}" # lowercase
        if [[ -z "$TYPE" ]]; then
          echo "Error: type cannot be empty."
          return 1
        fi
        ;;
      --project | -p)
        shift
        local PROJECT="${1:l}" # lowercase
        if [[ -z "$PROJECT" ]]; then
          echo "Error: project cannot be empty."
          return 1
        fi
        ;;
      --name | -n )
        shift
        local NAME="$1"
        NAME=${NAME:l} # lowercase words
        NAME=${NAME// /-} # substitute spaces with hyphens
        if [[ -z "$NAME" ]]; then
          echo "Error: name cannot be empty."
          return 1
        fi
        ;;
      --no-edit | -x )
        local NOEDITFLAG=1
        ;;
    esac; shift
  done

  # NOTE: we build the file name outside the while loop above because
  # the arguments may be passed in random order however we want to
  # construct the name in a specific order.
  local RESULT="$TYPE"
  if [[ "$PROJECT" ]]; then
    RESULT="$RESULT@$PROJECT"
  fi
  RESULT="$RESULT--$NAME.$NOTESFORMAT"

  if [[ ! -e "$RESULT" ]]; then
    echo "Info: $RESULT does not exist, creating file."
    touch $RESULT

    local TEMPLATEFILE="$TEMPLATEDIR/$TYPE"
    if [[ -e "$TEMPLATEFILE" ]]; then
      if [[ -x "$TEMPLATEFILE" ]]; then
        $TEMPLATEFILE $RESULT
      elif [[ -s "$TEMPLATEFILE" ]]; then
        cat $TEMPLATEFILE > $RESULT
      fi
    else
      echo "---" > $RESULT
      echo "title: $NAME" >> $RESULT
      echo "date: [$(date +'%Y-%m-%d')]" >> $RESULT
      echo "author: $AUTHOR" >> $RESULT
      echo "---" >> $RESULT
    fi
  fi

  [[ ! "$NOEDITFLAG" ]] && __edit $RESULT
}
# }}}

# Link {{{
__link() {
  emulate -L zsh

  # Backward Links {{{
  __backward_links() {
    emulate -L zsh

    echo "Info: backward links."
    $GREPPRG --max-depth 1 --files-with-matches --type $NOTESFORMAT "\($1\)" | \
      $GREPPRG --no-line-number --only-matching "^(.+)\.$NOTESFORMAT" -r '$1'
  }
  # }}}

  # Forward Links {{{
  __forward_links() {
    emulate -L zsh

    echo "Info: forward links."
    $GREPPRG '\((\d+-\d+-\d+--\w+--[\w-]+)\)' $1 --no-line-number \
      --only-matching --replace '$1'
  }
  # }}}

  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h )
        echo "link: show links for note."
        echo "--forward -f: show notes that given note links to."
        echo "--backward -b: show notes which link to given note."
        echo "--unlinked -u: show unlinked notes."
        return 0
        ;;
      --forward | -f )
        shift
        local FORWARDFLAG=1
        ;;
      --backward | -b )
        shift
        local BACKWARDFLAG=1
        ;;
      *)
        local NAME=${1:t:r} # file name without extension and absolute path
        break
        ;;
    esac
  done

  if [[ -z "$1" || ! -e "$1" ]]; then
    echo "Error: no or unexisting file specified."
    return 1
  fi

  if [[ -n "$FORWARDFLAG" ]]; then
    __forward_links $1
  elif [[ -n "$BACKWARDFLAG" ]]; then
    __backward_links $NAME
  else
    __forward_links $1
    __backward_links $NAME
  fi
}
# }}}

# Standup {{{
__standup() {
  emulate -L zsh

  local CAPTUREGLOB="*capture*.$NOTESFORMAT"

  if [[ -n "$1" ]]; then
    echo "Info: showing notes changed within $1."
    $FINDPRG --max-depth 1 --changed-within $1 --extension $NOTESFORMAT \
      --exclude $CAPTUREGLOB
  else
    echo "Info: showing notes changed within 1d."
    $FINDPRG --max-depth 1 --changed-within 1d --extension $NOTESFORMAT \
      --exclude $CAPTUREGLOB
  fi
}
# }}}

# Edit {{{
__edit() {
  emulate -L zsh

  $EDITOR + $@
}
# }}}

# Cat {{{
__cat() {
  local BG=$(tail -n 1 ~/.vim/.background)
  local WIDTH=72
  echo "Info: showing $@."
  $CATPRG -w $WIDTH -s $BG $@
}
# }}}

# Main {{{
if [[ "$PWD" != "$NOTESDIR" ]]; then
  pushd $NOTESDIR
  local PUSHDFLAG=1
fi

if [[ "$#" -eq 0 ]]; then
  __grep --state todo
else
  case "$1" in
    help)
      echo "z: knowledge management using standard unix tools."
      echo "capture: subcommand to open the default notes file and start capture process."
      echo "grep: subcommand to print a list of headers. See z grep --help for more info."
      echo "find: subcommand to print a list of files. See z find --help for more info."
      echo "cd: subcommand to change current directory to default notes directory."
      echo "new: subcommand to create new note file. See z new --help for more info."
      echo "link: subcommand to find links between notes. See z link --help for more info."
      echo "standup: subcommand to show latest modified notes."
      return 0
      ;;
    grep | rg | g)
      __grep "${@:2}"
      ;;
    find | fd | f)
      __find "${@:2}"
      ;;
    capture | cap | c)
      __capture "${@:2}"
      ;;
    new | n)
      __new "${@:2}"
      ;;
    cd)
      return 0 # already in NOTESDIR
      ;;
    cat)
      __cat "${@:2}"
      ;;
    rm | mv)
      rm ${@:2}
      ;;
    link | l)
      __link "${@:2}"
      ;;
    standup | stand | s)
      __standup "${@:2}"
      ;;
    agenda | age | a)
      __agenda
      ;;
    *)
      __edit $@
      ;;
  esac
fi

if [[ "$PUSHDFLAG" ]]; then
  popd
fi
# }}}
