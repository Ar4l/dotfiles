# vim: filetype=zsh foldmethod=marker
# knowledge management using unix tools.

# Init {{{
local GREPPRG=rg
local FINDPRG=fd
local AUTHOR="Arumoy Shome"
local CATPRG=glow
[[ -z $NOTESFORMAT ]] && local NOTESFORMAT="md"
[[ -z $NOTESDIR ]] && local NOTESDIR="$HOME/org"
[[ -z $TEMPLATEDIR ]] && local TEMPLATEDIR="$NOTESDIR/.templates"
[[ ! -d $NOTESDIR ]]  && mkdir -p $NOTESDIR
# }}}

# Agenda {{{
__agenda () {
  emulate -L zsh

  # 1: type
  # 2: project
  # 3: file name
  # 4: title
  local PRETTYRX="(\w+)@(\w+)--(.+)\.$NOTESFORMAT:#+\s(.+)$"
  local PRETTYPRINT=' $1|$2|$3|$4 '
  local QUERYRX='^#+\s.+'

  $GREPPRG --no-heading --no-line-number --with-filename --smart-case \
    --max-depth 1 --type $NOTESFORMAT $@ $QUERYRX | \
    $GREPPRG $PRETTYRX -r $PRETTYPRINT | column -t -s '|'
}
# }}}

# Capture {{{
__capture () {
  emulate -L zsh

  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h)
        echo "capture: convenient wrapper around new."
        echo "--project -p: specify a project."
        return 0
        ;;
      --project | -p)
        shift
        PROJECT="${1:l}" #lowercase
        if [[ -z "$PROJECT" ]]; then
          echo "Error: project cannot be empty."
          return 1
        fi
        ;;
      *)
        echo "Error: unknown option $1."
        return 1
        ;;
    esac; shift
  done

  local UUID=$(uuidgen)
  UUID=${UUID:l} # lowercase
  UUID=${UUID: -12} # last 12 chars

  if [[ "$PROJECT" ]]; then
    __new --type capture --name $UUID --project $PROJECT
  else
    __new --type capture --name $UUID
  fi
}
# }}}

# Grep {{{
__grep () {
  emulate -L zsh

  case "$1" in
    --help | -h )
      echo "grep: grep wrapper for notes files."
      echo "Invoke ripgrep with provided arguments."
      return 0
      ;;
    *)
      $GREPPRG --smart-case --max-depth 1 --type $NOTESFORMAT $@
      ;;
  esac
}
# }}}

# Find {{{
__find() {
  emulate -L zsh

  local NOTENAMERX="^\d+-\d+-\d+--${2:l}--[\w-]+"
  local SHOWTAGSRX="^\d+-\d+-\d+--(\w+)--[\w-]+\.$NOTESFORMAT"

  case "$1" in
    --help | -h )
      echo "find: print a list of files matching a specific tag."
      echo "--tag -t: print files matching the specified tag. Limit search to notes format."
      echo "--show-tags: print all notes files tags along with their count."
      echo "With any other arguments, invoke fd with provided arguments."
      echo "All additional arguments are passed to fd verbatim."
      return 0
      ;;
    --tag | -t )
      $FINDPRG --max-depth 1 --extension $NOTESFORMAT $NOTENAMERX ${@:3} # lowercase tags
      ;;
    --show-tags )
      # NOTE: we need two calls to sort, the first so that uniq works
      # as expected and the second to sort based on count of tags
      $FINDPRG --max-depth 1 --extension $NOTESFORMAT | $GREPPRG $SHOWTAGSRX -r '$1' | \
        sort | \
        uniq -c | \
        sort --reverse | \
        column
      ;;
    *)
      $FINDPRG --max-depth 1 --extension $NOTESFORMAT $@
  esac
}
# }}}

# New {{{
__new() {
  emulate -L zsh

  local TIMESTAMP=$(date +'%Y-%m-%d')
  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h )
        echo "new: create a new note file."
        echo "--no-edit -x: just create the file, don't open it."
        echo "--tag -t: specify the tag for the file. Must be a single word. Cannot be empty if used."
        echo "--name -n: specify the title of the file. Must be a string. Cannot be empty if used."
        echo "--tag and --name are mutually inclusive, one cannot be passed without the other."
        echo "When neither a tag nor a name is passed, a %Y-%m-%d timestamp is used to name the file."
        return 0
        ;;
      --tag | -t )
        shift
        local TAG="${1:l}" # lowercase
        if [[ -z "$TAG" ]]; then
          echo "Error: tag cannot be empty."
          return 1
        fi
        ;;
      --name | -n )
        shift; local NAME="$1"
        if [[ -z "$NAME" ]]; then
          echo "Error: name cannot be empty."
          return 1
        fi
        ;;
      --no-edit | -x )
        local NOEDITFLAG=1
        ;;
    esac; shift; done

    local RESULT="$TIMESTAMP"
    if [[ -n "$TAG" && -n "$NAME" ]]; then
      local FMTNAME=${NAME:l} # lowercase words
      local FMTNAME=${FMTNAME// /-} # substitute spaces with hyphens
      RESULT="$RESULT--$TAG--$FMTNAME"
    else
      echo "Warning: Either tag or name or both missing, using default naming."
    fi
    RESULT="$RESULT.$NOTESFORMAT"

    if [[ ! -e "$RESULT" ]]; then
      echo "Info: $RESULT does not exist, creating file."
      touch $RESULT

      local TEMPLATEFILE="$TEMPLATEDIR/$TAG"
      if [[ -e "$TEMPLATEFILE" ]]; then
        if [[ -x "$TEMPLATEFILE" ]]; then
          $TEMPLATEFILE $RESULT
        elif [[ -s "$TEMPLATEFILE" ]]; then
          cat $TEMPLATEFILE > $RESULT
        fi
      else
        echo "---" > $RESULT
        echo "title: $NAME" >> $RESULT
        echo "date: $TIMESTAMP" >> $RESULT
        echo "author: $AUTHOR" >> $RESULT
        echo "tag: $TAG" >> $RESULT
        echo "---" >> $RESULT
      fi
    fi

    [[ ! "$NOEDITFLAG" ]] && __edit $RESULT
}
# }}}

# Link {{{
__link() {
  emulate -L zsh

  # Backward Links {{{
  __backward_links() {
    emulate -L zsh

    echo "Info: backward links."
    $GREPPRG --max-depth 1 --files-with-matches --type $NOTESFORMAT "\($1\)" | \
      $GREPPRG --no-line-number --only-matching "^(.+)\.$NOTESFORMAT" -r '$1'
  }
  # }}}

  # Forward Links {{{
  __forward_links() {
    emulate -L zsh

    echo "Info: forward links."
    $GREPPRG '\((\d+-\d+-\d+--\w+--[\w-]+)\)' $1 --no-line-number \
      --only-matching --replace '$1'
    }
  # }}}

  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h )
        echo "link: show links for note."
        echo "--forward -f: show notes that given note links to."
        echo "--backward -b: show notes which link to given note."
        echo "--unlinked -u: show unlinked notes."
        return 0
        ;;
      --forward | -f )
        shift
        local FORWARDFLAG=1
        ;;
      --backward | -b )
        shift
        local BACKWARDFLAG=1
        ;;
      *)
        local NAME=${1:t:r} # file name without extension and absolute path
        break
        ;;
    esac
  done

    if [[ -z "$1" || ! -e "$1" ]]; then
      echo "Error: no or unexisting file specified."
      return 1
    fi

    if [[ -n "$FORWARDFLAG" ]]; then
      __forward_links $1
    elif [[ -n "$BACKWARDFLAG" ]]; then
      __backward_links $NAME
    else
      __forward_links $1
      __backward_links $NAME
    fi
}
# }}}

# Standup {{{
__standup() {
  emulate -L zsh

  local CAPTUREGLOB="*capture*.$NOTESFORMAT"

  if [[ -n "$1" ]]; then
    echo "Info: showing notes changed within $1."
    $FINDPRG --max-depth 1 --changed-within $1 --extension $NOTESFORMAT \
      --exclude $CAPTUREGLOB
  else
    echo "Info: showing notes changed within 1d."
    $FINDPRG --max-depth 1 --changed-within 1d --extension $NOTESFORMAT \
      --exclude $CAPTUREGLOB
  fi
}
# }}}

# Edit {{{
__edit() {
  emulate -L zsh

  if [[ -f "$1" && -e "$1" ]]; then
      $EDITOR $1
  else
    echo "Error: $1 does not exist."
    return 1
  fi
}
# }}}

# Cat {{{
__cat() {
  local BG=$(tail -n 1 ~/.vim/.background)
  local WIDTH=70
  echo "Info: showing $@."
  $CATPRG -w $WIDTH -s $BG $@
}
# }}}

# Main {{{
if [[ "$PWD" != "$NOTESDIR" ]]; then
  pushd $NOTESDIR
  local PUSHDFLAG=1
fi

if [[ "$#" -eq 0 ]]; then
  __grep --state todo
else
  case "$1" in
    help)
      echo "z: knowledge management using standard unix tools."
      echo "capture: subcommand to open the default notes file and start capture process."
      echo "grep: subcommand to print a list of headers. See z grep --help for more info."
      echo "find: subcommand to print a list of files. See z find --help for more info."
      echo "cd: subcommand to change current directory to default notes directory."
      echo "new: subcommand to create new note file. See z new --help for more info."
      echo "link: subcommand to find links between notes. See z link --help for more info."
      echo "standup: subcommand to show latest modified notes."
      return 0
      ;;
    grep | rg | g)
      __grep "${@:2}"
      ;;
    find | fd | f)
      __find "${@:2}"
      ;;
    capture | cap | c)
      __capture "${@:2}"
      ;;
    new | n)
      __new "${@:2}"
      ;;
    cd)
      return 0 # already in NOTESDIR
      ;;
    cat)
      __cat "${@:2}"
      ;;
    rm | mv)
      rm ${@:2}
      ;;
    link | l)
      __link "${@:2}"
      ;;
    standup | stand | s)
      __standup "${@:2}"
      ;;
    *)
      __edit $1
      ;;
  esac
fi

if [[ "$PUSHDFLAG" ]]; then
  popd
fi
# }}}
