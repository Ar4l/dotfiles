# vim: filetype=zsh foldmethod=marker
# knowledge management using unix tools.

# Init {{{
local GREPPRG=rg
local FINDPRG=fd
local AUTHOR="Arumoy Shome"
[[ -z $NOTESFORMAT ]] && local NOTESFORMAT="md"
[[ -z $NOTESDIR ]] && local NOTESDIR="$HOME/org"
[[ -z $NOTESFILE ]] && local NOTESFILE="$NOTESDIR/inbox.$NOTESFORMAT"
[[ ! -d $NOTESDIR ]]  && mkdir -p $NOTESDIR
[[ ! -e $NOTESFILE ]] && touch $NOTESFILE
# }}}

# Capture {{{
__capture () {
  emulate -L zsh
  local NOEDITFLAG="-c startinsert"
  local TEMPLATE="#"
  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h)
        echo "capture: open default notes file and start capture process."
        echo "--no-edit -n: open the default notes files but do not enter insert mode."
        echo "--state -s: add the specified state to the capture header."
        echo "--tag -t: add the specified tag to the capture header."
        echo "The default notes directory is: $NOTESDIR"
        echo "The default notes file is: $NOTESFILE"
        echo "The default notes format is: $NOTESFORMAT"
        return 0
        ;;
      --no-edit | -n)
        NOEDITFLAG=""
        ;;
      --state | -s)
        shift
        local STATE="$1"
        if [[ -z "$STATE" ]]; then
          echo "Error: state cannot be empty."
          return 1
        fi
        ;;
      --tag | -t)
        shift
        local TAG="$1"
        if [[ -z "$TAG" ]]; then
          echo "Error: tag cannot be empty."
          return 1
        fi
        ;;
      *)
        echo "Error: unknown option $1."
        return 1
        ;;
    esac; shift; done

    if [[ -n "$STATE" ]]; then
      STATE=${STATE:u} # uppercase
      TEMPLATE="$TEMPLATE $STATE"
    fi
    if [[ "$STATE" -eq "IDEA" ]]; then
      local TIMESTAMP=$(date +'%Y-%m-%d %H:%M')
      TEMPLATE="$TEMPLATE $TIMESTAMP"
    fi
    if [[ -n "$TAG" ]]; then
      TAG=${TAG:l} # lowercase
      TEMPLATE="$TEMPLATE {.$TAG}"
    fi
    if [[ -n "$NOEDITFLAG" ]]; then
      echo "$TEMPLATE" >> $NOTESFILE
    fi

    $EDITOR $NOEDITFLAG + $NOTESFILE # start at end of file (in insert mode)
  }
# }}}

# Grep {{{
# TODO: Allow the ability to pipe results from previous invocation.
__grep () {
  emulate -L zsh
  case "$1" in
    --help | -h )
      echo "grep: print a list of headers matching a specific state or tag."
      echo "--state -s: print headers matching the specified state. Limit search to notes format."
      echo "--State -S: same as above but search in all files."
      echo "--tag -t: print headers matching the specified tag. Limit search to notes format."
      echo "--Tag -T: same as above but search in all files."
      echo "With any other arguments, invoke ripgrep with provided arguments."
      echo "All additional arguments are passed to ripgrep verbatim."
      return 0
      ;;
    --state | -s )
      $GREPPRG --smart-case --type $NOTESFORMAT "^#+.$2.*" $NOTESDIR ${@:3}
      ;;
    --State | -S )
      $GREPPRG --smart-case "^#+.$2.*" $NOTESDIR ${@:3}
      ;;
    --tag | -t )
      $GREPPRG --smart-case --type $NOTESFORMAT "^#+.*\{[.#]$2\}$" $NOTESDIR ${@:3}
      ;;
    --Tag | -T )
      $GREPPRG --smart-case "^#+.*\{\.$2\}" $NOTESDIR ${@:3}
      ;;
    *)
      $GREPPRG --smart-case $@ $NOTESDIR
      ;;
  esac

}
# }}}

# Find {{{
__find() {
  emulate -L zsh
  case "$1" in
    --help | -h )
      echo "find: print a list of files matching a specific tag."
      echo "--tag -t: print files matching the specified tag. Limit search to notes format."
      echo "--Tag -T: same as above but search all files."
      echo "With any other arguments, invoke fd with provided arguments."
      echo "All additional arguments are passed to fd verbatim."
      return 0
      ;;
    --tag | -t )
      $FINDPRG --extension $NOTESFORMAT "^\d+-\d+-\d+--$2--.*" $NOTESDIR ${@:3}
      ;;
    --Tag | -T )
      $FINDPRG "^\d+-\d+-\d+--$2--.*" $NOTESDIR ${@:3}
      ;;
    *)
      $FINDPRG $@ $NOTESDIR
  esac
}
# }}}

# New {{{
# TODO: not sure about the name. This subcommand can also be used for
# editing exisiting note files as well?
__new() {
  emulate -L zsh
  local TIMESTAMP=$(date +'%Y-%m-%d')
  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h )
        echo "new: create a new note file."
        echo "--tag -t: specify the tag for the file. Must be a single word. Cannot be empty if used."
        echo "--name -n: specify the name of the file. Must be a string. Cannot be empty if used."
        echo "--tag and --name are mutually inclusive, one cannot be passed without the other."
        echo "When neither a tag nor a name is passed, a %Y-%m-%d timestamp is used to name the file."
        return 0
        ;;
      --tag | -t )
        shift
        local TAG="$1"
        if [[ -z "$TAG" ]]; then
          echo "Error: tag cannot be empty."
          return 1
        fi
        ;;
      --name | -n )
        shift; local NAME="$1"
        if [[ -z "$NAME" ]]; then
          echo "Error: name cannot be empty."
          return 1
        fi
        ;;
    esac; shift; done

    local RESULT="$TIMESTAMP"
    if [[ -n "$TAG" && -n "$NAME" ]]; then
      local FMTNAME=${NAME:l} # lowercase words
      local FMTNAME=${FMTNAME// /-} # substitute spaces with hyphens
      RESULT="$RESULT--$TAG--$FMTNAME"
    else
      echo "Warning: Either tag or name or both missing, using default naming."
    fi
    RESULT="$NOTESDIR/$RESULT.$NOTESFORMAT"

    if [[ ! -e "$RESULT" ]]; then
      echo "Info: $RESULT does not exist, creating file."
      touch $RESULT
      echo "---" > $RESULT
      echo "title: $NAME" >> $RESULT
      echo "date: $TIMESTAMP" >> $RESULT
      echo "author: $AUTHOR" >> $RESULT
      echo "tag: $TAG" >> $RESULT
      echo "---" >> $RESULT
    else
      echo "Info: $RESULT already exists, opening file."
    fi
    $EDITOR + $RESULT
}
# }}}

# Main {{{
if [[ "$#" -eq 0 ]]; then
  __capture && exit
else
  case "$1" in
    help)
      echo "z: knowledge management using standard unix tools."
      echo "capture: subcommand to open the default notes file and start capture process."
      echo "grep: subcommand to print a list of headers. See z grep --help for more info."
      echo "find: subcommand to print a list of files. See z find --help for more info."
      echo "cd: subcommand to change current directory to default notes directory."
      echo "new: subcommand to create new note file. See z new --help for more info."
      return 0
      ;;
    grep)
      __grep "${@:2}"
      ;;
    find)
      __find "${@:2}"
      ;;
    capture)
      __capture "${@:2}"
      ;;
    new)
      __new "${@:2}"
      ;;
    cd)
      cd $NOTESDIR
      ;;
    *)
      # do nothing
      ;;
  esac
fi
# }}}
