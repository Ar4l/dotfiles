# vim: filetype=zsh foldmethod=marker
# knowledge management using unix tools.

# Init {{{
local GREPPRG=rg
local FINDPRG=fd
local AUTHOR="Arumoy Shome"
local CATPRG=glow
[[ -z $NOTESFORMAT ]] && local NOTESFORMAT="md"
[[ -z $NOTESDIR ]] && local NOTESDIR="$HOME/org"
[[ -z $TEMPLATEDIR ]] && local TEMPLATEDIR="$NOTESDIR/.templates"
[[ -z $ARCHIVEDIR ]] && local ARCHIVEDIR="$NOTESDIR/.archive"
[[ ! -d $NOTESDIR ]]  && mkdir -p $NOTESDIR
[[ ! -d $ARCHIVEDIR ]]  && mkdir -p $ARCHIVEDIR
# }}}

# Capture {{{
__capture () {
  emulate -L zsh
  local TEMPLATE="#"
  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h)
        echo "capture: open default notes file and start capture process."
        echo "--state -s: specify a state for the capture header."
        echo "--tag -t: specify a tag for the capture header."
        echo "--name -n: specify a title for the capture header."
        echo "--priority -p: specify a priority for the capture header."
        echo "--no-edit -x: just create the header, don't open it."
        echo "The default notes directory is: $NOTESDIR"
        echo "The default notes format is: $NOTESFORMAT"
        return 0
        ;;
      --state | -s)
        shift
        local STATE="${1:u}" # uppercase
        if [[ -z "$STATE" ]]; then
          echo "Error: state cannot be empty."
          return 1
        fi
        ;;
      --tag | -t)
        shift
        local TAG="${1:l}" # lowercase
        if [[ -z "$TAG" ]]; then
          echo "Error: tag cannot be empty."
          return 1
        fi
        ;;
      --name | -n)
        shift
        local NAME="$1"
        if [[ -z "$NAME" ]]; then
          echo "Error: name cannot be empty."
          return 1
        fi
        ;;
      --priority | -p)
        shift
        local PRIORITY="$1"
        if [[ -z "$PRIORITY" ]]; then
          echo "Error: priority cannot be empty."
          return 1
        fi
        ;;
      --no-edit | -x)
        local NOEDITFLAG=1
        ;;
      *)
        echo "Error: unknown option $1."
        return 1
        ;;
    esac; shift; done

    # we have to do this outside of the args parsing above because the
    # order of constructing TEMPLATE matters.
    if [[ -n "$PRIORITY" ]]; then
      case "$PRIORITY" in
        low | l | !)
          TEMPLATE="$TEMPLATE !"
          ;;
        medium | m | !!)
          TEMPLATE="$TEMPLATE !!"
          ;;
        high | h | !!!)
          TEMPLATE="$TEMPLATE !!!"
          ;;
      esac
    fi
    if [[ -n "$STATE" ]]; then
      TEMPLATE="$TEMPLATE $STATE"
    fi
    if [[ "$STATE" == "IDEA" ]]; then
      local TIMESTAMP=$(date +'%Y-%m-%d %H:%M')
      TEMPLATE="$TEMPLATE $TIMESTAMP"
    fi
    if [[ -n "$NAME" ]]; then
      TEMPLATE="$TEMPLATE $NAME"
    fi
    if [[ -n "$TAG" ]]; then
      TEMPLATE="$TEMPLATE :$TAG:"
    fi

    local UUID=$(uuidgen)
    UUID=${UUID:l} # lowercase
    UUID=${UUID: -12} # last 12 chars
    local CAPTUREFILE="$(date +'%Y-%m-%d')--capture--${UUID}.$NOTESFORMAT"

    if [[ ! -e "$CAPTUREFILE" ]]; then
      echo "Info: $CAPTUREFILE does not exist, creating file."
      touch $CAPTUREFILE
      echo "$TEMPLATE" > $CAPTUREFILE
    fi

    [[ ! "$NOEDITFLAG" ]] && __edit $CAPTUREFILE
  }
# }}}

# Grep {{{
__grep () {
  emulate -L zsh

  local STATERX='[[:upper:]]+'
  local TAGRX='.+'
  local PRIORITYRX='!{0,3}'
  local SHOWTAGSRX='^#+.+:(.+):$'
  # 1: timestamp
  # 2: file tag
  # 3: file name
  # 4: priority
  # 5: state
  # 6: title
  # 7: tag
  local PRETTYRX="(\d+-\d+-\d+)--(\w+)--(.+)\.$NOTESFORMAT:#+\s(!{1,3}\s)?([[:upper:]]+\s)?(.+)(\s:.+:)$"
  local PRETTYPRINT=' $4,$1,$3,$5,$6,$7 '

  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h )
        echo "grep: print a list of headers matching a specific state or tag."
        echo "--state -s: print headers matching the specified state."
        echo "--tag -t: print headers matching the specified tag."
        echo "--priority -p: print headers matching the specified priority."
        echo "--show-tags: print all tags in notes files along with their count."
        echo "With any other arguments, invoke ripgrep with provided arguments."
        echo "All additional arguments are passed to ripgrep verbatim."
        return 0
        ;;
      --state | -s)
        shift
        if [[ -n "$1" ]]; then
          STATERX="${1:u}" # uppercase
        else
          echo 'Error: state cannot be empty.'
          return 1
        fi
        ;;
      --tag | -t)
        shift
        if [[ -n "$1" ]]; then
          TAGRX="${1:l}" # lowercase
        else
          echo 'Error: tag cannot be empty.'
          return 1
        fi
        ;;
      --priority | -p )
        shift
        if [[ -n "$1" ]]; then
          PRIORITYRX=$1
        else
          echo 'Error: priority cannot be empty.'
          return 1
        fi
        ;;
      --show-tags )
        # NOTE: we need two calls to sort, the first so that uniq works
        # as expected and the second to sort based on count of tags
        $GREPPRG --max-depth 1 --type $NOTESFORMAT --no-heading --no-filename \
          --no-line-number $SHOWTAGSRX -r '$1' | \
          sort | \
          uniq -c | \
          sort --reverse | \
          column

        return 0
        ;;
      *)
        echo "Error: unknown flag $1"
        return 1
        ;;
    esac; shift
  done

  local QUERYRX='^#+\s' # one or more # followed by whitespace
  QUERYRX+=$PRIORITYRX # zero or more !
  QUERYRX+='\s?' # optional whitespace
  QUERYRX+=$STATERX
  QUERYRX+='\s' # whitespace
  QUERYRX+='.+' # match all
  QUERYRX+=":$TAGRX:$" # end tag

  $GREPPRG --no-heading --no-line-number --with-filename --smart-case \
    --max-depth 1 --type $NOTESFORMAT $@ $QUERYRX | \
    $GREPPRG $PRETTYRX -r $PRETTYPRINT | column -t -s ,
}

# }}}

# Find {{{
__find() {
  emulate -L zsh

  local NOTENAMERX="^\d+-\d+-\d+--${2:l}--[\w-]+"
  local SHOWTAGSRX="^\d+-\d+-\d+--(\w+)--[\w-]+\.$NOTESFORMAT"

  case "$1" in
    --help | -h )
      echo "find: print a list of files matching a specific tag."
      echo "--tag -t: print files matching the specified tag. Limit search to notes format."
      echo "--show-tags: print all notes files tags along with their count."
      echo "With any other arguments, invoke fd with provided arguments."
      echo "All additional arguments are passed to fd verbatim."
      return 0
      ;;
    --tag | -t )
      $FINDPRG --max-depth 1 --extension $NOTESFORMAT $NOTENAMERX ${@:3} # lowercase tags
      ;;
    --show-tags )
      # NOTE: we need two calls to sort, the first so that uniq works
      # as expected and the second to sort based on count of tags
      $FINDPRG --max-depth 1 --extension $NOTESFORMAT | $GREPPRG $SHOWTAGSRX -r '$1' | \
        sort | \
        uniq -c | \
        sort --reverse | \
        column
      ;;
    *)
      $FINDPRG --max-depth 1 --extension $NOTESFORMAT $@
  esac
}
# }}}

# New {{{
__new() {
  emulate -L zsh

  local TIMESTAMP=$(date +'%Y-%m-%d')
  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h )
        echo "new: create a new note file."
        echo "--no-edit -x: just create the file, don't open it."
        echo "--tag -t: specify the tag for the file. Must be a single word. Cannot be empty if used."
        echo "--name -n: specify the title of the file. Must be a string. Cannot be empty if used."
        echo "--tag and --name are mutually inclusive, one cannot be passed without the other."
        echo "When neither a tag nor a name is passed, a %Y-%m-%d timestamp is used to name the file."
        return 0
        ;;
      --tag | -t )
        shift
        local TAG="${1:l}" # lowercase
        if [[ -z "$TAG" ]]; then
          echo "Error: tag cannot be empty."
          return 1
        fi
        ;;
      --name | -n )
        shift; local NAME="$1"
        if [[ -z "$NAME" ]]; then
          echo "Error: name cannot be empty."
          return 1
        fi
        ;;
      --no-edit | -x )
        local NOEDITFLAG=1
        ;;
    esac; shift; done

    local RESULT="$TIMESTAMP"
    if [[ -n "$TAG" && -n "$NAME" ]]; then
      local FMTNAME=${NAME:l} # lowercase words
      local FMTNAME=${FMTNAME// /-} # substitute spaces with hyphens
      RESULT="$RESULT--$TAG--$FMTNAME"
    else
      echo "Warning: Either tag or name or both missing, using default naming."
    fi
    RESULT="$RESULT.$NOTESFORMAT"

    if [[ ! -e "$RESULT" ]]; then
      echo "Info: $RESULT does not exist, creating file."
      touch $RESULT

      local TEMPLATEFILE="$TEMPLATEDIR/$TAG"
      if [[ -e "$TEMPLATEFILE" ]]; then
        if [[ -x "$TEMPLATEFILE" ]]; then
          $TEMPLATEFILE $RESULT
        elif [[ -s "$TEMPLATEFILE" ]]; then
          cat $TEMPLATEFILE > $RESULT
        fi
      else
        echo "---" > $RESULT
        echo "title: $NAME" >> $RESULT
        echo "date: $TIMESTAMP" >> $RESULT
        echo "author: $AUTHOR" >> $RESULT
        echo "tag: $TAG" >> $RESULT
        echo "---" >> $RESULT
      fi
    fi

    [[ ! "$NOEDITFLAG" ]] && __edit $RESULT
}
# }}}

# Forward Links {{{
__forward_links() {
  emulate -L zsh

  echo "Info: forward links."
  $GREPPRG '\((\d+-\d+-\d+--\w+--[\w-]+)\)' $1 --no-line-number \
    --only-matching --replace '$1'
}
# }}}

# Backward Links {{{
__backward_links() {
  emulate -L zsh

  echo "Info: backward links."
  $GREPPRG --max-depth 1 --files-with-matches --type $NOTESFORMAT "\($1\)" | \
    $GREPPRG --no-line-number --only-matching "^(.+)\.$NOTESFORMAT" -r '$1'
}
# }}}

# Link {{{
__link() {
  emulate -L zsh

  while [[ "$1" =~ - && ! "$1" == "--" ]]; do
    case "$1" in
      --help | -h )
        echo "link: show links for note."
        echo "--forward -f: show notes that given note links to."
        echo "--backward -b: show notes which link to given note."
        echo "--unlinked -u: show unlinked notes."
        return 0
        ;;
      --forward | -f )
        shift
        local FORWARDFLAG=1
        ;;
      --backward | -b )
        shift
        local BACKWARDFLAG=1
        ;;
      *)
        local NAME=${1:t:r}
        break
        ;;
    esac; done

    if [[ -z "$1" || ! -e "$1" ]]; then
      echo "Error: no or unexisting file specified."
      return 1
    fi

    if [[ -n "$FORWARDFLAG" ]]; then
      __forward_links $1
    elif [[ -n "$BACKWARDFLAG" ]]; then
      __backward_links $NAME
    else
      __forward_links $1
      __backward_links $NAME
    fi
}
# }}}

# Standup {{{
__standup() {
  emulate -L zsh

  local CAPTUREGLOB="*capture*.$NOTESFORMAT"

  if [[ -n "$1" ]]; then
    $FINDPRG --max-depth 1 --changed-within $1 --extension $NOTESFORMAT \
      --exclude $CAPTUREGLOB
  else
    $FINDPRG --max-depth 1 --changed-within 1d --extension $NOTESFORMAT \
      --exclude $CAPTUREGLOB
  fi
}
# }}}

# Edit {{{
__edit() {
  emulate -L zsh

  if [[ -f "$1" && -e "$1" ]]; then
      $EDITOR $1
  else
    echo "Error: $1 does not exist."
    return 1
  fi
}
# }}}

# Cat {{{
__cat() {
  local BG=$(tail -n 1 ~/.vim/.background)
  local WIDTH=70
  echo "Info: showing $@."
  $CATPRG -w $WIDTH -s $BG $@
}
# }}}

# Main {{{
if [[ "$PWD" != "$NOTESDIR" ]]; then
  pushd $NOTESDIR
  local PUSHDFLAG=1
fi

if [[ "$#" -eq 0 ]]; then
  __grep --state todo
else
  case "$1" in
    help)
      echo "z: knowledge management using standard unix tools."
      echo "capture: subcommand to open the default notes file and start capture process."
      echo "grep: subcommand to print a list of headers. See z grep --help for more info."
      echo "find: subcommand to print a list of files. See z find --help for more info."
      echo "cd: subcommand to change current directory to default notes directory."
      echo "new: subcommand to create new note file. See z new --help for more info."
      echo "link: subcommand to find links between notes. See z link --help for more info."
      echo "standup: subcommand to show latest modified notes."
      return 0
      ;;
    grep | rg | g)
      __grep "${@:2}"
      ;;
    find | fd | f)
      __find "${@:2}"
      ;;
    capture | cap | c)
      __capture "${@:2}"
      ;;
    new | n)
      __new "${@:2}"
      ;;
    cd)
      return 0 # already in NOTESDIR
      ;;
    cat)
      __cat "${@:2}"
      ;;
    rm | mv)
      mv ${@:2} $ARCHIVEDIR
      ;;
    link | l)
      __link "${@:2}"
      ;;
    standup | stand | s)
      __standup "${@:2}"
      ;;
    *)
      __edit $1
      ;;
  esac
fi

if [[ "$PUSHDFLAG" ]]; then
  popd
fi
# }}}
